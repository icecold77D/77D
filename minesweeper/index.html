<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>è¸©åœ°é›· Minesweeper</title>
  <style>
    :root{
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #6ee7b7;
      --muted: #94a3b8;
      --danger: #ff6b6b;
      --tile: linear-gradient(180deg,#0b1220,#071021);
      --tile-open: linear-gradient(180deg,#0f1724,#08111c);
      --tile-border: rgba(255,255,255,0.03);
      --glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Arial; background: radial-gradient(circle at 10% 10%, #071226, #04101a 40%, var(--bg)); color:#e6eef6}
    .container{max-width:980px;margin:28px auto;padding:20px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: 0 8px 30px rgba(2,6,23,0.6)}
    header{display:flex;gap:16px;align-items:center;justify-content:space-between;margin-bottom:16px}
    h1{font-size:20px;margin:0}
    .controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    select,input{background:var(--card);border:1px solid var(--tile-border);color:var(--muted);padding:8px;border-radius:8px}
    button{background:linear-gradient(180deg,#123244,#0d2636);color:#dff6ef;border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;cursor:pointer}
    button:hover{transform:translateY(-1px)}
    .status{display:flex;gap:12px;align-items:center}
    .badge{padding:6px 10px;border-radius:8px;background:var(--glass);border:1px solid var(--tile-border);min-width:72px;text-align:center}
    .board-wrap{display:flex;gap:20px;align-items:flex-start}
    .board{display:grid;background:transparent;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);box-shadow: inset 0 1px 0 rgba(255,255,255,0.02)}
    .tile{
      width:34px;height:34px;display:flex;align-items:center;justify-content:center;
      margin:2px;border-radius:6px;background:var(--tile);border:1px solid var(--tile-border);
      font-weight:600;color:#dff6ef;user-select:none;cursor:pointer;
      font-size:14px;
      box-shadow: 0 2px 0 rgba(0,0,0,0.6), 0 1px 0 rgba(255,255,255,0.02) inset;
    }
    .tile.open{background:var(--tile-open);cursor:default;color:#cbd8e6;border:1px solid rgba(255,255,255,0.04)}
    .tile.flag{color:var(--accent)}
    .tile.mine{color:var(--danger);background:linear-gradient(180deg,#330808,#2a0505)}
    .tile.number-1{color:#2ea3ff}
    .tile.number-2{color:#28d49c}
    .tile.number-3{color:#ffb36b}
    .tile.number-4{color:#a78bfa}
    .tile.number-5{color:#ff7ab6}
    .tile.number-6{color:#18c5c8}
    .tile.number-7{color:#f59e0b}
    .tile.number-8{color:#9ca3af}
    .legend{color:var(--muted);font-size:13px;margin-top:10px}
    .footer{margin-top:14px;color:var(--muted);font-size:13px}
    @media (max-width:640px){
      .tile{width:30px;height:30px;font-size:13px}
    }
  </style>
</head>
<body>
  <div class="container" role="main">
    <header>
      <div>
        <h1>è¸©åœ°é›· Â· Minesweeper â€” ç¥ä½ æ‰‹æ°£å¥½ ğŸ€</h1>
        <div class="legend">å·¦éµé–‹æ ¼ / å³éµæ¨™æ——ï¼ˆæˆ–æŒ‰ä½ Alt + å·¦éµï¼‰ / ç¬¬ä¸€æ¬¡é»æ“Šä¿è­‰å®‰å…¨</div>
      </div>

      <div class="controls">
        <label>
          é›£åº¦ï¼š
          <select id="preset">
            <option value="9x9x10">ç°¡å–® 9Ã—9 Â· 10 åœ°é›·</option>
            <option value="16x16x40">ä¸­ç­‰ 16Ã—16 Â· 40 åœ°é›·</option>
            <option value="16x30x99">å›°é›£ 16Ã—30 Â· 99 åœ°é›·</option>
            <option value="8x12x12">ä¼‘é–’ 8Ã—12 Â· 12 åœ°é›·</option>
          </select>
        </label>

        <label>
          è‡ªè¨‚ï¼šè¡Œ <input id="rows" type="number" value="9" min="5" max="40" style="width:72px"> åˆ— <input id="cols" type="number" value="9" min="5" max="60" style="width:72px"> åœ°é›· <input id="mines" type="number" value="10" min="1" style="width:80px">
        </label>

        <button id="resetBtn">é‡ç½®</button>
        <div class="status">
          <div class="badge">å‰©é¤˜ï¼š<span id="mineCount">0</span></div>
          <div class="badge">æ™‚é–“ï¼š<span id="timer">0</span>s</div>
        </div>
      </div>
    </header>

    <div class="board-wrap">
      <div id="board" class="board" aria-label="Minesweeper board"></div>
      <aside style="min-width:170px">
        <div style="background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);">
          <h3 style="margin:4px 0 8px 0">èªªæ˜</h3>
          <p style="margin:0 0 8px 0;color:var(--muted)">- ç¬¬ä¸€æ¬¡é»æ“Šå¾Œæ‰æœƒæ”¾åœ°é›·ï¼ˆé¿å…ä¸€é–‹å§‹å°±ç‚¸æ­»ï¼‰ã€‚<br>- ç¿»é–‹æ•¸å­—è¡¨ç¤ºé™„è¿‘ 8 æ ¼çš„åœ°é›·æ•¸é‡ã€‚<br>- ç•¶ä½ æ­é–‹æ‰€æœ‰éåœ°é›·æ ¼å­å³è´ã€‚</p>
          <div style="margin-top:8px"><button id="hintBtn">å¿«é€Ÿæ­é–‹ 0 çš„å€åŸŸ (debug)</button></div>
        </div>
      </aside>
    </div>

    <div class="footer">æç¤ºï¼šå³éµåœ¨æŸäº›è§¸æ§æ¿éœ€æŒ‰å…©æŒ‡é»æˆ–é•·æŒ‰ã€‚ç¥ä½ ä¸è¦è¸©åˆ°åœ°é›·ï¼</div>
  </div>

<script>
/*
  Minesweeper JavaScript
  åŠŸèƒ½ï¼š
  - ç¬¬ä¸€é¡†æ–¹æ ¼é»æ“Šå‰ä¸æ”¾é›·ï¼ˆfirst click safeï¼‰
  - å·¦éµæ­é–‹ã€å³éµæ¨™æ——ï¼ˆcontextmenu æ””æˆªï¼‰
  - è‡ªè¨‚èˆ‡é è¨­é›£åº¦ã€é‡è¨­ã€è¨ˆæ™‚
*/

(() => {
  // DOM
  const boardEl = document.getElementById('board');
  const presetEl = document.getElementById('preset');
  const rowsEl = document.getElementById('rows');
  const colsEl = document.getElementById('cols');
  const minesEl = document.getElementById('mines');
  const resetBtn = document.getElementById('resetBtn');
  const mineCountEl = document.getElementById('mineCount');
  const timerEl = document.getElementById('timer');
  const hintBtn = document.getElementById('hintBtn');

  // state
  let rows = 9, cols = 9, totalMines = 10;
  let grid = []; // cells
  let firstClick = true;
  let timer = null, elapsed = 0;
  let flagsPlaced = 0;
  let gameOver = false;
  let cellsToReveal = 0;

  // helpers
  function idx(r,c){ return r*cols + c; }
  function inBounds(r,c){ return r>=0 && r<rows && c>=0 && c<cols; }

  // Cell structure:
  // { r, c, mine:false, open:false, flagged:false, adj:0, el }
  function createGrid(){
    grid = new Array(rows*cols);
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        grid[idx(r,c)] = { r,c, mine:false, open:false, flagged:false, adj:0, el:null };
      }
    }
  }

  function placeMinesAvoiding(firstR, firstC){
    // place totalMines mines randomly but avoid the first clicked cell and its neighbors
    const forbidden = new Set();
    for(let dr=-1;dr<=1;dr++){
      for(let dc=-1;dc<=1;dc++){
        const rr = firstR+dr, cc = firstC+dc;
        if(inBounds(rr,cc)) forbidden.add(idx(rr,cc));
      }
    }
    let placed = 0;
    const total = rows*cols;
    while(placed < totalMines){
      const pos = Math.floor(Math.random()*total);
      if(forbidden.has(pos)) continue;
      const cell = grid[pos];
      if(!cell.mine){
        cell.mine = true;
        placed++;
      }
    }
    // compute adj counts
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cell = grid[idx(r,c)];
        if(cell.mine) { cell.adj = -1; continue; }
        let count = 0;
        for(let dr=-1;dr<=1;dr++){
          for(let dc=-1;dc<=1;dc++){
            if(dr===0 && dc===0) continue;
            const rr=r+dr, cc=c+dc;
            if(inBounds(rr,cc) && grid[idx(rr,cc)].mine) count++;
          }
        }
        cell.adj = count;
      }
    }
  }

  function buildBoard(){
    boardEl.innerHTML = '';
    boardEl.style.gridTemplateColumns = `repeat(${cols}, auto)`;
    boardEl.style.gridTemplateRows = `repeat(${rows}, auto)`;
    boardEl.className = 'board';
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cell = grid[idx(r,c)];
        const el = document.createElement('div');
        el.className = 'tile';
        el.setAttribute('data-r', r);
        el.setAttribute('data-c', c);
        el.setAttribute('role','button');
        el.setAttribute('aria-label', `cell ${r},${c}`);
        // events
        el.addEventListener('click', (ev) => handleLeftClick(ev, cell));
        el.addEventListener('contextmenu', (ev) => handleRightClick(ev, cell));
        // alt+click for mobile / some cases
        el.addEventListener('auxclick', (ev) => {
          if(ev.button===1){ handleRightClick(ev, cell); }
        });
        cell.el = el;
        boardEl.appendChild(el);
      }
    }
  }

  function startTimer(){
    if(timer) clearInterval(timer);
    elapsed = 0;
    timerEl.textContent = '0';
    timer = setInterval(()=>{
      elapsed++;
      timerEl.textContent = elapsed;
    }, 1000);
  }
  function stopTimer(){ if(timer){ clearInterval(timer); timer=null; } }

  function revealCell(cell){
    if(cell.open || cell.flagged) return;
    cell.open = true;
    cell.el.classList.add('open');
    if(cell.mine){
      cell.el.classList.add('mine');
      cell.el.textContent = 'ğŸ’£';
      return;
    }
    cellsToReveal--;
    if(cell.adj>0){
      cell.el.classList.add('number-'+cell.adj);
      cell.el.textContent = cell.adj;
    } else {
      cell.el.textContent = '';
      // flood fill neighbors
      for(let dr=-1;dr<=1;dr++){
        for(let dc=-1;dc<=1;dc++){
          if(dr===0 && dc===0) continue;
          const rr = cell.r+dr, cc = cell.c+dc;
          if(inBounds(rr,cc)){
            const n = grid[idx(rr,cc)];
            if(!n.open && !n.flagged && !n.mine) revealCell(n);
          }
        }
      }
    }
  }

  function handleLeftClick(ev, cell){
    if(gameOver) return;
    // support Alt+click as right-click (for touch)
    if(ev.altKey){
      return toggleFlag(cell);
    }
    if(firstClick){
      // initialize mines now (so first click safe)
      placeMinesAvoiding(cell.r, cell.c);
      startTimer();
      firstClick = false;
    }
    if(cell.flagged || cell.open) return;
    if(cell.mine){
      // lose
      revealAllMines(cell);
      endGame(false);
      return;
    }
    revealCell(cell);
    checkWin();
  }

  function handleRightClick(ev, cell){
    ev.preventDefault();
    if(gameOver || cell.open) return;
    toggleFlag(cell);
  }

  function toggleFlag(cell){
    if(cell.open) return;
    cell.flagged = !cell.flagged;
    cell.el.classList.toggle('flag', cell.flagged);
    cell.el.textContent = cell.flagged ? 'ğŸš©' : '';
    flagsPlaced += cell.flagged ? 1 : -1;
    updateMineCount();
  }

  function revealAllMines(triggerCell){
    for(const c of grid){
      if(c.mine){
        c.el.classList.add('open','mine');
        if(!c.flagged) c.el.textContent = 'ğŸ’£';
      }
      if(c.flagged && !c.mine){
        // wrong flag
        c.el.textContent = 'âŒ';
        c.el.classList.add('open');
      }
    }
    if(triggerCell){
      triggerCell.el.classList.add('mine');
    }
  }

  function checkWin(){
    if(cellsToReveal === 0 && !gameOver){
      // auto flag remaining mines for UI neatness
      for(const c of grid){ if(c.mine && !c.flagged){ c.flagged = true; c.el.classList.add('flag'); c.el.textContent='ğŸš©'; } }
      endGame(true);
    }
  }

  function endGame(won){
    gameOver = true;
    stopTimer();
    setTimeout(()=>{
      if(won){
        alert(`ä½ è´äº†ï¼ç”¨æ™‚ ${elapsed} ç§’ ğŸ‰`);
      } else {
        alert('ä½ è¸©åˆ°åœ°é›·äº† ğŸ’¥ éŠæˆ²çµæŸ');
      }
    }, 50);
  }

  function updateMineCount(){
    const remaining = Math.max(0, totalMines - flagsPlaced);
    mineCountEl.textContent = remaining;
  }

  function resetGame(){
    // read config
    rows = parseInt(rowsEl.value,10) || 9;
    cols = parseInt(colsEl.value,10) || 9;
    totalMines = parseInt(minesEl.value,10) || 10;
    // sanity
    const maxM = Math.floor(rows*cols*0.6);
    if(totalMines >= rows*cols){ totalMines = Math.max(1, rows*cols - 1); minesEl.value = totalMines; }
    if(totalMines > maxM){ totalMines = maxM; minesEl.value = totalMines; }
    firstClick = true; gameOver = false; flagsPlaced = 0;
    stopTimer();
    timerEl.textContent = '0';
    mineCountEl.textContent = totalMines;
    cellsToReveal = rows*cols - totalMines;
    createGrid();
    buildBoard();
    // accessibility: focus first tile
    const firstTile = boardEl.querySelector('.tile');
    if(firstTile) firstTile.tabIndex = 0;
  }

  // preset handling
  presetEl.addEventListener('change', ()=>{
    const v = presetEl.value.split('x').map(Number);
    if(v.length===3){
      rowsEl.value = v[0];
      colsEl.value = v[1];
      minesEl.value = v[2];
      resetGame();
    }
  });

  resetBtn.addEventListener('click', ()=>{
    resetGame();
  });

  // hint button (debug helper: reveal a zero area)
  hintBtn.addEventListener('click', ()=>{
    // find a zero cell and reveal its area
    for(const c of grid){
      if(!c.mine && c.adj===0){
        if(firstClick){
          // can't reveal before mines placed; just simulate first click at that zero
          placeMinesAvoiding(c.r,c.c);
          firstClick=false;
          startTimer();
        }
        revealCell(c);
        checkWin();
        break;
      }
    }
  });

  // keyboard accessibility: space reveal, F to flag
  document.addEventListener('keydown', (e)=>{
    const focused = document.activeElement;
    if(!focused || !focused.classList.contains('tile')) return;
    const r = parseInt(focused.dataset.r,10), c = parseInt(focused.dataset.c,10);
    const cell = grid[idx(r,c)];
    if(e.code === 'Space' || e.key === ' '){ handleLeftClick(new MouseEvent('click'), cell); e.preventDefault(); }
    if(e.key.toLowerCase() === 'f'){ toggleFlag(cell); e.preventDefault(); }
    // arrow navigation
    if(e.key.startsWith('Arrow')){
      let nr=r, nc=c;
      if(e.key==='ArrowUp') nr--;
      if(e.key==='ArrowDown') nr++;
      if(e.key==='ArrowLeft') nc--;
      if(e.key==='ArrowRight') nc++;
      if(inBounds(nr,nc)){
        const el = grid[idx(nr,nc)].el;
        el.focus();
      }
    }
  });

  // update custom inputs when user edits them
  rowsEl.addEventListener('change', ()=>{ presetEl.value = ''; resetGame(); });
  colsEl.addEventListener('change', ()=>{ presetEl.value = ''; resetGame(); });
  minesEl.addEventListener('change', ()=>{ presetEl.value = ''; resetGame(); });

  // initial
  resetGame();

  // expose for debugging in console
  window._ms = { grid, resetGame, revealAllMines };
})();
</script>
</body>
</html>
